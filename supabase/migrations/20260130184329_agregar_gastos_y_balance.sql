
  create table "public"."gastos" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "monto" numeric not null
      );


alter table "public"."gastos" enable row level security;

CREATE UNIQUE INDEX gastos_pkey ON public.gastos USING btree (id);

alter table "public"."gastos" add constraint "gastos_pkey" PRIMARY KEY using index "gastos_pkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.obtener_balance(fecha_inicio timestamp with time zone, fecha_fin timestamp with time zone)
 RETURNS TABLE(total_agua numeric, total_crema numeric, plata_transferencia numeric, plata_efectivo numeric, costo_envio_total numeric, cantidad_envios numeric, total_gastos numeric, cantidad_gastos numeric, efectivo_final numeric, ingreso_total numeric)
 LANGUAGE plpgsql
AS $function$
begin
  return query

  -- 1. Calculamos los totales de PEDIDOS
  with resumen_pedidos as (
    select
      -- 1. Suma de cantidades (excluyendo cancelados) 
      coalesce(sum(cantidad_agua), 0):: numeric as t_agua,
      coalesce(sum(cantidad_crema), 0):: numeric as t_crema,
      
      -- 2. Plata por Transferencia (Suma de montos donde metodo = transferencia)
      coalesce(sum(
        case when metodo_pago = 'transferencia' 
             then coalesce(precio_total,0)
             else 0 end
      ), 0) as p_transferencia,

      -- 3. Plata Efectivo (Ingreso Bruto)
      coalesce(sum(
        case when metodo_pago = 'efectivo' 
             then coalesce(precio_total,0)
             else 0 end
      ), 0) as p_efectivo,

      -- 4. Costo de envíos (Solo sumamos si hay costo > 0)
      coalesce(sum(costo_envio), 0) as c_envio,

      -- 5. Cantidad de envíos (Contamos cuántos pedidos tuvieron costo > 0)
      count(case when costo_envio > 0 then 1 else null end):: numeric as q_envios

    from public.pedidos
    where created_at >= fecha_inicio 
      and created_at <= fecha_fin
      and estado != 'cancelado'
  ),

  -- 2. Calculamos los totales de GASTOS
  resumen_gastos as (
    select 
      coalesce(sum(monto), 0):: numeric as t_gastos,

      count(*):: numeric as q_gastos

    from public.gastos
    where created_at >= fecha_inicio 
      and created_at <= fecha_fin
  )
  -- Ahora sí, seleccionamos y hacemos la resta simple
  select 
    p.t_agua,
    p.t_crema,
    p.p_transferencia,
    p.p_efectivo,
    p.c_envio,
    p.q_envios,
    g.t_gastos,
    g.q_gastos,
    (p.p_efectivo - p.c_envio - g.t_gastos) as efectivo_final,
    (p.p_efectivo + p.p_transferencia) as ingreso_total
  from resumen_pedidos p
  cross join resumen_gastos g;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.manage_single_active_lista()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Si la nueva lista (o la editada) viene como activa
  IF NEW.activa IS TRUE THEN
    -- Desactivar todas las demas listas (excluyendo la actual si fuera un update)
    UPDATE public.listas_precios
    SET activa = false
    WHERE id <> NEW.id AND activa = true;
  END IF;
  
  RETURN NEW;
END;
$function$
;

grant delete on table "public"."gastos" to "anon";

grant insert on table "public"."gastos" to "anon";

grant references on table "public"."gastos" to "anon";

grant select on table "public"."gastos" to "anon";

grant trigger on table "public"."gastos" to "anon";

grant truncate on table "public"."gastos" to "anon";

grant update on table "public"."gastos" to "anon";

grant delete on table "public"."gastos" to "authenticated";

grant insert on table "public"."gastos" to "authenticated";

grant references on table "public"."gastos" to "authenticated";

grant select on table "public"."gastos" to "authenticated";

grant trigger on table "public"."gastos" to "authenticated";

grant truncate on table "public"."gastos" to "authenticated";

grant update on table "public"."gastos" to "authenticated";

grant delete on table "public"."gastos" to "postgres";

grant insert on table "public"."gastos" to "postgres";

grant references on table "public"."gastos" to "postgres";

grant select on table "public"."gastos" to "postgres";

grant trigger on table "public"."gastos" to "postgres";

grant truncate on table "public"."gastos" to "postgres";

grant update on table "public"."gastos" to "postgres";

grant delete on table "public"."gastos" to "service_role";

grant insert on table "public"."gastos" to "service_role";

grant references on table "public"."gastos" to "service_role";

grant select on table "public"."gastos" to "service_role";

grant trigger on table "public"."gastos" to "service_role";

grant truncate on table "public"."gastos" to "service_role";

grant update on table "public"."gastos" to "service_role";


  create policy "Usuarios pueden ver y crear gastos"
  on "public"."gastos"
  as permissive
  for all
  to authenticated
using (true)
with check (true);



